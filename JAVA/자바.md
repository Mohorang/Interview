### **자바**

#### **객체지향 프로그래밍이란?**

객체지향 프로그래밍이란 필요한 데이터들만 뽑아내 추상화해서 상태와 행위를 가진 객체로 만들고 이 객체체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 기법을 객체지향 프로그래밍 기법이라고 합니다. 

객체란 객체지향 프로그래밍의 근본이 되는것으로 값을 저장하는 변수와 변수에 대한 행동을 하는 메서드를 묶어서 객체 라고 합니다. 객체는 레고에 빗대어 설명할 수 있습니다. 레고조각들이 모여서 하나의 물체가 되고 레고들은 다양한 곳에서 재사용 될 수가 있는데 이게 객체 지향 프로그래밍의 특징인 재사용성을 나타낼 수 있습니다.

객체지향 프로그래밍에는 캡슐화,상속,추상화,다형성이라는 4가지 원칙이 존재합니다.

* 캡슐화 : 캡슐화란 클래스 내부의 속성과 메서드들을 숨겨서 외부에서 알 수 없도록 하는 것을 말합니다. 이를 통해 사용자는 내부 구조를 몰라도 사용할 수 있습니다.
* 상속 : 상속이란 상위클래스의 성질을 그대로 이어받아서 새로운 하위 클래스를 만들어 내어 상위클래스의 요소들을 그대로 이용할 수 있게 하는 기능을 말합니다.
* 추상화 : 추상화라는 것은 클래스를 만드는 작업과 같은데 사물에서 필요한 특징들만 뽑아내어 모아놓는 작업을 추상화 라고 합니다. 추상화를 통해 상속과 비슷하게 코드의 재사용성을 높일 수 있습니다.
* 다형성 : 다형성이란 클래스나 메서드가 다양한 형태를 가지는 것을 다형성이라고 합니다. 자바에서 대표적인 다형성의 예로 오버로딩과 오버라이딩이 존재합니다.

#### **자바는 실행되면 어떤식으로 실행될까??**

* 개발자가 코드를 작성한다 -> 자바 컴파일러에 의해 소스파일이 .class의 바이트 코드가 생성된다  -> 클래스로더가 바이트 코드를 메모리에 올린다. -> 이를 실행엔진이 실행한다. -> 반복
* 클래스들은 한번에 실행되지 않는다.실행엔진은 클래스로더에 필요한 클래스를 요청하고 이를 메모리에 올리게 되는 순서이다.
* 클래스 로드 과정
  * 로딩 : .class파일을 JVM에 로드하는 과정
  * 링킹 : 3가지 단계로 나뉜다.
    * 검증 :  바이트 코드가 제대로 자바의 규칙을 따르고 있는지 검증하는 단계
    * 준비 :  클래스가 필요로 하는 메모리 양을 미리 할당하는 단계
    * 분석 :  클래스가 참조하는 객체에 대해서 실제 메모리 값을 대입하는 단계
  * 초기화 : 클래스 안에 스태틱 변수를 할당하고 초기화시키는 단계

#### **가비지 컬렉션이 뭐에요??**

자바에서 메모리들을 재활용하기 위해 더이상 참조되지 않는 객체들을 자동으로 제거해주는 모듈을 가비지 컬렉션 이라고 합니다. 자바에서는 힙 영역에 객체들을 저장하는데 이 힙이라는 공간에서 G.C가 동작하여 사용하지 않는 객체들을 제거하게 됩니다. 

GC의 장점 : 개발자가 직접 메모리를 제거하지 않아도 되어 개발속도가 상향되는 장점이 있다.

GC의 단점 : G.C는 동작할 때 Mark and Sweep이라고 하여 참조되는 객체와 참조되지 않는 객체들을 구별하는 과정을 거치는데 이 때 모든 스레드가 잠시 중단되어서 상대적으로 성능이 떨어진다는 단점이 있습니다.

Young 영역에서 동작하는 Minor G.C : 객체들은 처음 생성되면 Eden영역에 생성이 되는데 이 영역이 곽차면 MinorG.C가 동작을 하는데 살아남은 객체들은 survivor영역으로 이동하며 age가 증가하는데 일정수준의 age가 되면 Old영역(MajorGC)으로 이동하게 된다. 이 영역의 객체들은 계속해서 참조되어왔던 객체들인데 이 안에서 Old영역이 가득차게 되면 MajorGC가 동작하게 됩니다.

#### **객체지향 설계원칙 SOLID**

SRP : 단일책임 원칙으로 하나의 클래스가 수정되어야 할 이유는 한가지여야 한다는 원칙입니다. 여기서 의미하는 단일 책임 원칙을 준수하지 않으면 하나의 클래스가 변경되는 것으로 다른 클래스에도 영향을 끼칠 수 있습니다.

OCP : 개방폐쇄의 원칙으로 소프트웨어는 확장에는 열려있으나 변경에는 닫혀있어야 한다는 원칙입니다.

LSP : 리스코프 치환 원칙으로 상위타입의 객체를 하위타입의 객체로 바꿔도 같은 동작을 보장해야 한다는 원칙입니다.

ISP : 인터페이스 분리 원칙으로 인터페이스 하나에 여러 동작을 넣기보다는 각각 독립된 인터페이스를 여러개 만드는게 더 좋다는 원칙입니다. 단일책임원칙의 인터페이스 버전이라고 할 수 있습니다.

DIP : 의존관계역전 법칙으로 클라이언트는 추상화된 인터페이스에 의존해야지 인터페이스의 구현체에 의존해서는 안된다는 원칙입니다.  의존성 주입은 이 원칙을 따르는 방법중 하나입니다.



### 접근제어자란??

접근제어자 라는것은 클래스 안에서 변수나 메서드들이 있는데 이것들의 사용범위를 결정하는 것이 접근제어자 입니다. 접근제어자는 자바에서 캡슐화를 준수하는데 사용됩니다. 캡슐화 라는 것은 객체지향의 원리중 하나로 클래스 내부의 필드와 메서드를 숨겨 외부에서 구현내용을 알 수 없도록 은닉하는 것을 말합니다.

**접근제어자는 왜 사용할까요??**

* 외부에서 클래스 내부의 필드나 메서드에 접근하지 못하게 하기 위해 사용합니다. 이는 OOP의 캡슐화를 준수하기 위해 사용하는데 캡슐화 라는 것은 클래스 내부정보를 외부로 부터 숨겨서 결합도를 낮추는데 사용됩니다.
* 접근제어자에는 public , protected , default , private 4가지가 있습니다.
* public은 모든곳에서 사용할 수 있으며 protected는 같은 패키지와 이 클래스를 상속받은 곳에서 사용할 수 있습니다. defuault는 같은 패키지 내에서만 사용할 수 있으며 private 는 같은 클래스 안에서만 사용할 수 있습니다.

### **컬렉션프레임워크란?**

컬렉션 프레임워크란 객체군을 다룰 수 있는 라이브러리 입니다. 컬렉션 프레임워크의 종류로는 리스트,큐,셋,맵 네가지가 존재합니다.

#### **리스트** (List)

* 리스트는 순서를 보장하며 데이터의 중복이 가능한 자료구조 입니다. 리스트의 종류는 다음과 같습니다. 
  * ArrayList : ArrayList는 Array와 비슷하게 순차적으로 데이터를 저장하는 자료구조로 배열을 사용해서 객체들을 관리하는 자료구조입니다.
    ArrayList의 경우 Array와는 다릅니다. 가장 큰 차이로는 Array의 경우 선언할 때 크기를 지정해 줘야 하며 ArrayList는 크기가 가변적입니다. Array는 primitive type의 데이터만 들어갈 수 있으며 ArrayList는 Object만 들어갈 수 있습니다. ArrayList초기 디폴트 허용용량이 10인데 설정해둔 용량보다 커지는 경우 자동적으로 사이즈가 늘어나는 작업이 이뤄집니다.
    Array는 가장 큰 특징으로 순차적으로 데이터를 저장한다는 점인데 따라서 Array는 데이터가 자주 변경되지 않는 데이터를 담을 때 사용하기적절합니다. Array나  ArrayList의 경우 삽입 또는 삭제 과정에서O(n) 의 시간이 걸리게 되는데 이는 과정에서 각 원소들을 shift해줘야 하기 때문입니다.
  * LinkedList : 링크드 리스트는 비 연속적인 데이터들의 집합으로 자신의 값과 다음 노드의 참조값을 가지고 있습니다. 따라서 빠른 삽입과 삭제가 가능하지만 원하는 위치에 접근하는데 시간이 걸린다는 단점이 있습니다.
  * vector 는 thread-safe한 arrayList입니다.

#### **Set**

Set은 기본적으로 중복을 허용하지 않습니다. Set은 HashCode

* HastSet
  * Hash란 무엇인가?? : 어떤 데이터에 대해서 이 데이터를 해싱함수를 통해 숫자로 변환하는것을 해시 라고 합니다. hashcode라는 메서드를 통해서 해시값을 통해 확인하고 같으면 equals 메서드를 통해 또 한번 비교하게 되며 여기까지 통과하면 같은 객체라고 판단해 저장하지 않게 됩니다. 이래서 클래스의 안에 equals메서드 뿐 아니라 hashcode메서드까지 재정의가 필요합니다.
* TreeSet은 compareTo()메서드를 사용해서 중복체크를 하게된다. 트리의 경우 재배열이 이뤄지기 때문에 삽입 삭제는 속도가 느린데 검색에는 속도가 빠르다는 장점이 있다.
* LinkedHashSet : Hashcode를 통해서 중복값을 찾는데 이 클래스 내부에 LinkedList가 포함되어 있어 입력순서도 확인할 수 있다.

#### **Map**

Map은 <Key,Value>타입으로 객체를 저장하는 타입입니다. Key값은 해싱을 통해 유일한 값으로 저장되므로 중복을 허용하지 않지만 Key에 들어가는 value는 중복을 허용한다는 특징을 가지고 있다.

* HashMap : 
* HashTable : HashMap과 유사하지만 Thread-safe하다는 특징이 있다. 또한 해시 테이블은 null값을 허용하지 않지만 해시 맵의 경우 null값을 허용한다는 특징이 있다.
* LinkedHashMap : LinkedHashSet과 같이 내부에 LinkedList를 가지고 있어 입력순서를 저장한다.
* TreeMap : 이진트리를 기반으로 한 맵인데

#### Stack & Queue&Tree&Heap

Stack : Last in First Out의 형태를 가진 자료구조로 나중에 들어간 데이터가 가장 먼저나오는 자료구조이며 대표적으로는 자바의 Stack메모리 영역이 Stack자료구조를 따르고 있습니다.

Queue : 큐는 FIFO형태를 띄고 있어 먼저 들어온 데이터가 먼저 나가게 되는 구조로 되어 있습니다. 

Tree : Tree는 스택과 큐와 같은 선형 구조가 아닌 비선형 자료구조이며 노드와 엣지로 구성되어 있습니다.

Heap : 힙은 최대값, 최소값을 쉽게 찾아내기 위해 고안된 구조로 각 노드의 키 값이 자식의 키값보다 무조건 크거나(최대힙) 무조건 작은(최소힙) 완전 이진트리입니다. 여기서 완전이진트리란 부모노드의 자식노드가 최대높이 이전까지는 2개로 꽉차있는 트리를 말합니다.



#### **제네릭이 뭐에요??**

제네릭이란 자바8부터 등장한 개념으로 클래스나 메서드를 사용할 때 사용할 데이터 타입을 미리 클래스를 사용할 때 받아오도록 하는 기능을 제네릭이라고 합니다. 대표적으로 컬렉션 같은 경우에 원래는 Object로 객체들을 저장했기 때문에 이 데이터들을 꺼내서 사용할 때 데이터 타입을 체크해 줬어야 했습니다. 이 때 ClassCastException과 같은 컴파일 단계에서 발생할 수 있는데 제네릭을 사용하면 따로 형변환을 해줄 필요도 없고 잘못된 타입을 사용했을때 컴파일 단계에서 에러를 발생시켜줘서 개발자가 편해집니다.



#### **Wrapper 클래스**

int,double,short,char,byte,short,float,long과 같은 primitve type의 데이터들을 객체로 사용하기 위해 사용하는게 wrapper클래스 입니다. wrapper클래스의 경우 immutable하다는 특징이 있습니다. primitive -> wrapper타입으로 변환하는 과정을 박싱 , 그 반대의 과정을 언박싱 이라고 합니다. JDK1.5부터는 박싱과 언박싱이필요한 상황에 자동으로 처리를 해주는데 이를 오토박싱,언박싱 이라고 합니다.